<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Ferite Developers Guide 1.0 - Extending and Embedding The Ferite Engine</title>
<link rel="stylesheet" href="style.css" type="text/css">
</head><body>
<h1 class="documentTitle">The Ferite Developers Guide 1.0 - Extending and Embedding The Ferite Engine</h1><a name="toc" /><h3 class="tocTitle">Table of Contents</h3><blockquote class="toc"><a href="#introduction.title">1. Introduction</a><br /><br /><a href="#creating-basic-modules.title">2. Creating Basic Modules</a><br /><br /><a href="#creating-native-modules.title">3. Creating Native Modules</a><br /><span style="color:#fff;">____</span><a href="#cnm-introduction.title">3.1. Introduction</a><br /><span style="color:#fff;">____</span><a href="#cnm-builder.title">3.2. Builder</a><br /><span style="color:#fff;">____</span><a href="#cnm-builder-file-contents.title">3.3. Ferite-C File Contents</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-module-header.title">3.3.1. module-header</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-module-init.title">3.3.2. module-init</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-module-deinit.title">3.3.3. module-deinit</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-module-register-and-unregister.title">3.3.4. module-register and module-unregister</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-native-functions.title">3.3.5. Native Functions, the <tt class="monospace">builder</tt> way</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-nf-parameters.title">3.3.5.1. Parameters</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-nf-return-values.title">3.3.5.2. Return Values</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#cnm-bfc-nf-finally.title">3.3.5.3. And Finally</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#nfc-bnm-classes-and-namespaces.title">3.3.6. Classes and Namespaces</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#nfc-bnm-cn-odata.title">3.3.6.1. Self Data</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#nfc-bnm-finally.title">3.3.7. Finally</a><br /><span style="color:#fff;">____</span><a href="#cnm-without-builder.title">3.4. Without Builder</a><br /><br /><a href="#accessing-ferite-internals.title">4. Accessing Ferite Internals</a><br /><span style="color:#fff;">____</span><a href="#afi-introduction.title">4.1. Introduction</a><br /><span style="color:#fff;">____</span><a href="#afi-ferite-memory-manager.title">4.2. The Memory Manager</a><br /><span style="color:#fff;">____</span><a href="#afi-variables.title">4.3. Working With Variables</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-accessing-variables-meta-data.title">4.3.1. Accessing a Variable's Data</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-changing-variables-type.title">4.3.2. Changing a Variable's Type</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-creation-and-deletion-of-variables.title">4.3.3. Creating and Destroying Variables</a><br /><span style="color:#fff;">____</span><a href="#afi-working-with-namespaces.title">4.4. Working With Namespaces</a><br /><span style="color:#fff;">____</span><a href="#afi-working-with-objects-and-classes.title">4.5. Working With Objects And Classes</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-wwoc-creation.title">4.5.1. Creating Classes</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-wwoc-object-creation.title">4.5.2. Creating Objects</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-accessing-variables.title">4.5.3. Accessing Variables</a><br /><span style="color:#fff;">____</span><span style="color:#fff;">____</span><a href="#afi-accessing-functions.title">4.5.4. Accessing Functions</a><br /><span style="color:#fff;">____</span><a href="#afi-calling-functions.title">4.6. Calling Functions</a><br /><span style="color:#fff;">____</span><a href="#afi-errors.title">4.7. Raising Exceptions and Reporting Errors</a><br /><span style="color:#fff;">____</span><a href="#executing-code-snippets.title">4.8. Executing Code Snippets</a><br /><br /><a href="#native-modules-by-hand.title">5. Native Modules - By Hand</a><br /><span style="color:#fff;">____</span><a href="#nmbh-functions.title">5.1. Functions</a><br /><span style="color:#fff;">____</span><a href="#nmbh-main-bit.title">5.2. The Rest</a><br /><br /><a href="#embedding-ferite.title">6. Embedding Ferite</a><br /><span style="color:#fff;">____</span><a href="#ef-getting-the-engine-purring.title">6.1. Getting The Engine Purring</a><br /><span style="color:#fff;">____</span><a href="#ef-fake-native-modules.title">6.2. Fake Native Modules</a><br /><br /><a href="#7-buildingmodules">7. Building Modules</a><br /><span style="color:#fff;">____</span><a href="#71-mostcompatiblemethodgenerate-module">7.1. Most Compatible Method: generate-module</a><br /><span style="color:#fff;">____</span><a href="#72-newmethodfarm">7.2. New Method: farm</a><br /></blockquote><hr class="documentStart" /><a name="introduction"></a><a name="introduction.title"></a><h1 class="sectionTitle">1. Introduction<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><p class="para"> It is highly recommended that you read the <tt class="monospace">ferite</tt> manual before you continue with this      manual as it relies on the fact your are fluent with the terminology and structure of a <tt class="monospace">ferite</tt> program. </p><p class="para"> This document is provided to make it easier to do one (or all) of several things: write a ferite      module, write a native module to use with ferite - both with and without using <tt class="monospace">builder</tt> tool,      accessing the internals of the ferite engine: calling functions, changing variables, creating       objects etc. It is suggested that you read this with the C api documentation allowing you to       read the up to date information about the functions discussed. </p></blockquote> <hr class="sectionSplitter" /><a name="creating-basic-modules"></a><a name="creating-basic-modules.title"></a><h1 class="sectionTitle">2. Creating Basic Modules<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><p class="para"> A module is really nothing more than a <tt class="monospace">ferite</tt> script that resides within <tt class="monospace">ferite</tt>s module search path.       By default, the <tt class="monospace">ferite</tt> command line tool will look for modules in the current directory and the system's <tt class="monospace">ferite</tt> module directory (usually this is found in the directory <tt class="monospace">/usr/lib/ferite/module-source/</tt>,      although this fact can change from platform to platform). The module must have a file extension of either       <tt class="monospace">.fe</tt>, <tt class="monospace">.feh</tt> or <tt class="monospace">.fec</tt> in order to be recognized       by ferite. The convention is that constants and the default values for a module should be stored within a <tt class="monospace">.feh</tt> file, modules mixed with native code should have the extension <tt class="monospace">.fec</tt>, and the normal <tt class="monospace">ferite</tt> code in a <tt class="monospace">.fe</tt> file. It is       important to note that <tt class="monospace">ferite</tt> treats all these files the same, it just provides the ability to have the      different extensions to make the intended use of the file more obvious. </p><p class="para"> Essentially any script that you write can be included as a module. A script can import       modules and other scripts by using either the <tt class="monospace">uses</tt> keyword, or the <tt class="monospace">include()</tt> operation. When you import a module, you refer to it by its filename,       minus the .fe, .feh or .fec extension. So <tt class="monospace">mymodule.fe</tt> would be imported by <tt class="monospace">uses "mymodule";</tt> - <tt class="monospace">ferite</tt> will automatically search the extensions. <tt class="monospace">ferite</tt> will correctly resolve relative paths when importing a module. </p><p class="para"> The following example shows a script importing a module and accessing an exposed function,      and the module that is imported. They are in separate files residing in the same directory. </p><p class="para"><strong class="strong">File 1 (the importer); Name: myscript.fe</strong></p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br /></pre></td><td><pre class="code-linesright">uses "mymodule";
foo.bar();</pre></td></tr></table><p class="para"><strong class="strong">File 2 (the module); Name: mymodule.fe</strong></p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br /></pre></td><td><pre class="code-linesright">uses "console";

namespace foo{
    function bar(){
        Console.println("Hello there!");
    }
}</pre></td></tr></table><p class="para"><strong class="strong">Execution and result:</strong></p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">$ ferite myscript.fe
Hello there!
$</pre></td></tr></table><p class="para"> In the previous example, the module had exposed a namespace (foo), and a function within that       namespace (bar).  However, this is not the limit of what can be exposed. Modules can expose       functions, classes, namespaces, and global variables. Like regular scripts, modules can also       modify existing namespaces and classes by using the <tt class="monospace">modifies</tt> keyword. There is nothing special       that a module must do in order to expose functionality. When a module       creates a namespace, it is automatically exposed. The same goes for classes, functions and       global variables. </p><p class="para"> Something that should be noted, is that any code in the anonymous function of the module will       be executed when the module is first imported. You can safely put run-once initialization       code in a module's anonymous function. </p><p class="para"> Here is an example of a module taking advantage of several abilities. </p><p class="para"><strong class="strong">Name: myothermodule.fe</strong></p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br /></pre></td><td><pre class="code-linesright">uses "console";

global {
    number gMyNumber = 7;
}

class myclass {
    string WhatISaid;

    function constructor(string WhatToSay){
        Console.println(WhatToSay);
        self.WhatISaid = WhatToSay;
    }

    function tryme(){
        Console.println("You called myclass.tryme()!");
        Console.println("When created, I said: " + self.WhatISaid);
    }
}

namespace mynamespace {
    function hellothere(){
        Console.println("Hello there!");
    }
}

function plainfunction(){
    Console.println("You called plainfunction()!");
}

Console.println("I could be a module initializer!");</pre></td></tr></table><p class="para"> This code would result in <tt class="monospace">gMyNumber</tt> being exposed as a global variable.       The class <tt class="monospace">myclass</tt> would be available, as well as all of its class members. The namespace 'mynamespace' would      also become available, and it would house a single function called <tt class="monospace">hellothere</tt>. You would      also get a function called <tt class="monospace">plainfunction</tt> placed in the main namespace, accessible simply      by its name. And to top it off, upon the importing of the module, the <tt class="monospace">Console.println</tt> statement would be executed. This is a very important feature to note, as it allows for module      writers to place initialisation code that will be executed. </p><p class="para"> The next task is to cover native modules. </p></blockquote> <hr class="sectionSplitter" /><a name="creating-native-modules"></a><a name="creating-native-modules.title"></a><h1 class="sectionTitle">3. Creating Native Modules<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><a name="cnm-introduction"></a><a name="cnm-introduction.title"></a><h2 class="sectionTitle">3.1. Introduction<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	A native module is a <tt class="monospace">ferite</tt> module that contains native code to interface with the surrounding	system. This can be of two main forms, a mix of both native code and <tt class="monospace">ferite</tt> script (which is	how the base modules for <tt class="monospace">ferite</tt> are written) or they can be completely made up of native code.	Native code, in these examples, is C code. </p><p class="para">	Native modules can either be written by hand in the native language, written in ferite-c and converted	to 100% native code, or, the prefered option, use ferite-c to build a hybrid module. This section covers	the method used to create a hybrid module. These are by far the easiest to maintain and very quick and	easy to build. Modules that do not require the ferite-c file at runtime are dicussed later, after <tt class="monospace">builder</tt>	tool and accessing the internals of <tt class="monospace">ferite</tt> has been dicussed. This is due to the fact that they are	harder to write and require knowledge of the <tt class="monospace">ferite</tt> internals. </p></blockquote><a name="cnm-builder"></a><a name="cnm-builder.title"></a><h2 class="sectionTitle">3.2. Builder<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	Ferite-c files (.fec) are compiled using a special tool, called <tt class="monospace">builder</tt> which is run on the command	line. <tt class="monospace">builder</tt> is only used for the creation of native modules. It is not required in order to run	pre-built native modules. Depending on your <tt class="monospace">ferite</tt> installation, you may need to install a development	package to have access to <tt class="monospace">builder</tt>.      </p><p class="para"><strong class="strong">What does builder do?</strong></p><p class="para"><tt class="monospace">builder</tt> reads a ferite-c file and creates the necessary C source, header files and automake file 	that will be needed to compile the module. It takes several command line parameters,	only a few of which we will cover here. You can pass <tt class="monospace">builder</tt> either <tt class="monospace">--help</tt> or <tt class="monospace">-h</tt> on the command line to see all of the available options. <tt class="monospace">builder</tt>, by default,	assumes that you are going to build a hybrid module and generates the code for this.      </p><p class="para">	The switch we are currently most interested is -m. The -m switch allows you to specify the name of your 	module to <tt class="monospace">builder</tt>. This name will be used to determine the names of the files <tt class="monospace">builder</tt> will create 	while reading the ferite-c file. If you do not specify a name using -m, it will defaultto <tt class="monospace">modulename</tt>. For simplicity we will also use the -c and -f switches, which prevent the 	creation of a config.m4 and Makefile.am, respectively.      </p><p class="para"><strong class="strong">Example of using <tt class="monospace">builder</tt>:</strong></p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">$ builder -c -f -m mymodule mymodule.fec</pre></td></tr></table><p class="para">	When you run <tt class="monospace">builder</tt>, it will create several output files, named according to the module name. The main	files created are:      </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><i class="emphasis">modulename</i>_core.c (holds the register, unregister, init and deinit functions)</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><i class="emphasis">modulename</i>_misc.c (holds native code for the anonymous/_start function, if any)</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><i class="emphasis">modulename</i>_header.h (holds include statements that the various c files need)</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><i class="emphasis">modulename</i>_<i class="emphasis">classname</i>.c (you will get one of these for every class defined in the .fec)</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><i class="emphasis">modulename</i>_<i class="emphasis">namespacename</i>.c (you will get one of these for every namespace in the .fec)</p></p></li></ul><p class="para">	These files will need to be compiled into a shared object or a DLL (depending on your platform). For 	simplicity, we will simply refer to shared objects from here on, but they are interchangeable with DLL's. 	Both the resulting shared object and the original ferite-c file are needed for <tt class="monospace">ferite</tt> to successfully 	import the module. You will need to place the ferite-c file in the module path, which was explained in 	the previous section. The shared object will need to be placed in the native search path. This is where<tt class="monospace">ferite</tt> looks for all native modules. It is usually <tt class="monospace">/usr/lib/ferite/module-native/</tt><i class="emphasis">platform</i>, 	though the actual location may vary depending on the installation (ex. <tt class="monospace">/usr/lib/ferite/module-native/linux-gnu-i686</tt>).      </p><p class="para"><strong class="strong">Note:</strong> If you are interested in auto generation tools for standalone modules, you will	probably be interested in the	generate-module utility. <tt class="monospace">builder</tt> creates input files for automake and the like specifically tailored for modules	that will be included with the <tt class="monospace">ferite</tt> source. The <tt class="monospace">generate-module</tt> utility is geared more 	towards auto generation for	standalone modules. The other tool that can be used is <tt class="monospace">farm</tt>. Both these tools are covered	later in this guide.      </p></blockquote><a name="cnm-builder-file-contents"></a><a name="cnm-builder-file-contents.title"></a><h2 class="sectionTitle">3.3. Ferite-C File Contents<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	Ferite-c files are very similar to basic modules. In fact you can quite easily run <tt class="monospace">builder</tt> on a basic module. 	You just would end up with a lot of source files that didn't have much content. In order to get some content into 	those files, we need to tell <tt class="monospace">builder</tt> what parts of our module are written in C, instead of <tt class="monospace">ferite</tt> script. To 	do this, there are several new sections and keywords that we can place within our ferite-c file. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">uses "modulename.lib"</pre></td></tr></table><p class="para">	One of the most important pieces of a ferite-c file, is a uses statement at the top that tells <tt class="monospace">ferite</tt> at runtime 	to load the shared object file for the native module. </p><p class="para">	When you compile the files that <tt class="monospace">builder</tt> creates into a shared object, <tt class="monospace">ferite</tt> has no way of knowing the resulting 	file's name. Usually, people will compile it into a file called <i class="emphasis">modulename</i>.so, where 	<i class="emphasis">modulename</i> is the name of	the module. However this is not required. You could quite easily compile a module from source obtained by building	bob.fec, and call it jimmy.so. </p><p class="para">	The solution is to explicitly tell <tt class="monospace">ferite</tt> to load a shared object by name. This is done with a special case of the 	uses statement. The syntax is much like the normal uses statement, only you place a .lib extension on the name of 	the module that is to be imported. This is such that <tt class="monospace">ferite</tt> can know to load the native library for that platform	without forcing the programmer to take into account specifics of that platform. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">uses "bob.lib";</pre></td></tr></table><p class="para">	This will tell <tt class="monospace">ferite</tt> to look in the native module path for a file called bob.so on <tt class="monospace">Linux</tt> and	bob.dylib on <tt class="monospace">Mac OS X</tt>, and to import it. This type of a uses statement can also be used within	a regular <tt class="monospace">ferite</tt> script to load a native only module. </p><a name="cnm-bfc-module-header"></a><a name="cnm-bfc-module-header.title"></a><h3 class="sectionTitle">3.3.1. module-header<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  The module-header section is where you will place any #include statements, or #define statements, or anything 	  else that you expect your native code will need. The syntax for creating a module-header in a ferite-c file is 	  much like defining a global section in a regular script. The code that is declared within the 	  <tt class="monospace">module-header</tt>	  is availible in all generated C files.	</p><p class="para">For example:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">module-header {
    <i class="emphasis">...your headers go here...</i>
}</pre></td></tr></table><p class="para">	  Anything you place within the module-header section will be placed in the <i class="emphasis">modulename</i>_header.h 	  file when	  <tt class="monospace">builder</tt> parses the ferite-c file. This header is then included in every C source file that <tt class="monospace">builder</tt> creates.	  You can have as many <tt class="monospace">module-header</tt> blocks, the code will just be all placed together in the header	  file.</p><p class="para">Here is an example of a module-header:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">module-header {
    #include &lt;stdio.h&gt;
    #include "utility.h"
}</pre></td></tr></table><p class="para"><tt class="monospace">builder</tt> doesn't do any validity checking in between the curly braces. So if you have typographical errors, you 	  probably won't know until you try to compile the module.</p></blockquote><a name="cnm-bfc-module-init"></a><a name="cnm-bfc-module-init.title"></a><h3 class="sectionTitle">3.3.2. module-init<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  This section allows you to specify native code that is executed when the module is loaded into a script. It is an	  optional section, but <tt class="monospace">builder</tt> will create an empty module-init function in the C source. This function will be	  executed when the uses "modulename.lib" is executed.</p><p class="para">	  The module's _start function (sometimes referred to as the anonymous function) is also executed when it is first 	  imported, but module-init code is executed first. Also, the _start function cannot contain native code. So if your 	  module initialization requires multiple jumps between native and <tt class="monospace">ferite</tt> code, you can use the _start function to 	  call native functions where necessary and use <tt class="monospace">ferite</tt> code for everything else.</p><p class="para">The syntax for creating a module-init section is similar to module-header:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">module-init {
    <i class="emphasis">...your code goes here...</i>
}</pre></td></tr></table><p class="para">	  This will cause all of the code placed within the curly braces to be placed in the module's init function.	  In case you're interested, the build destination is the <i class="emphasis">modulename</i>_core.c file, in a 	  function called <i class="emphasis">modulename</i>_init(). The function returns void and has 1 parameter, 	  "FeriteScript *script", which is accessible to the code within the section.	</p></blockquote><a name="cnm-bfc-module-deinit"></a><a name="cnm-bfc-module-deinit.title"></a><h3 class="sectionTitle">3.3.3. module-deinit<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  This section is syntactically almost identical to the module-init section. Like module-init, module-deinit	  is not a required section. Again, <tt class="monospace">builder</tt> will create empty module-deinit function in the C source for	  you if you do not specify one. This function is called when a script is being deleted.</p><p class="para">	  Code in this section is executed when the script that loaded the module is being deleted. More precisely, 	  it is run by a call to ferite_script_delete(). However, you usually don't have to worry about the specifics 	  unless you're embedding <tt class="monospace">ferite</tt> in your application. For most purposes, just know that this code is run when	  the script has finished executing.</p><p class="para">Here is an example of a module-deinit section:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">module-deinit {
    <i class="emphasis">...your code goes here...</i>
}</pre></td></tr></table><p class="para">	  As you can see, it is basically the same as module-init. The return type is void, so you shouldn't try 	  returning anything from this function. It also has the affected script passed into it, which is accessed 	  exactly the same as you would for module-init.	</p></blockquote><a name="cnm-bfc-module-register-and-unregister"></a><a name="cnm-bfc-module-register-and-unregister.title"></a><h3 class="sectionTitle">3.3.4. module-register and module-unregister<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  When a native module's shared object is loaded, its register function is called once. This allows the 	  shared object to setup any system specific things. Symetrically, module-unregister is only called once,	  and that is when the <tt class="monospace">ferite</tt> module system decides to unload the shared object. They are both blocks of	  code like module-init and module-deinit and should be used the same way.</p></blockquote><a name="cnm-bfc-native-functions"></a><a name="cnm-bfc-native-functions.title"></a><h3 class="sectionTitle">3.3.5. Native Functions, the <tt class="monospace">builder</tt> way<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  When developing a native module with <tt class="monospace">builder</tt> it will be necessary to create functions that can be called	  by <tt class="monospace">ferite</tt> scripts. To make this easy there are only two main differences between a <tt class="monospace">ferite</tt> function and	  a native function. These are the keyword <tt class="monospace">native</tt> and that the bodies of the functions	  are written in C.</p><p class="para">First we'll start with an example of how to declare a simple native function:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">native function foo() {
    <i class="emphasis">...your code goes here...</i>
}</pre></td></tr></table><p class="para">	  This would result in the C source between the curly braces being placed in one of the C source files. 	  The exact file and the exact function name created depends on the namespace or class that the function 	  is declared in. This might vary from version to version so I won't get into it here, but feel free to 	  look at the source created. You'll probably be able to figure it out from there. To a scripter the	  function looks and tastes the same as a normal <tt class="monospace">ferite</tt> function.</p><p class="para">	  It should be noted that within each function the following variables are accessable:	</p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">script</tt> - a pointer to the FeriteScript in which the function was called.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">function</tt> - a pointer to the FeriteFunction which owns the function executing.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">params</tt> - the null terminated list of parameters (see Calling Functions for more information).</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">self</tt> - <strong class="strong">Note!</strong> for a function that is an object function, selfwill point to the FeriteObject*, for a namespace it will point to the FeriteNamespace* that the function lives in, for a class function it will point to the FeriteClass* the function lives in.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">current_recipient</tt> - A pointer to the current closure that may have been passed                into the function. The <tt class="monospace">deliver</tt> keyword, that is used within a ferite script, uses this                closure and calls the <tt class="monospace">invoke</tt> function on it.</p></p></li></ul><a name="cnm-bfc-nf-parameters"></a><a name="cnm-bfc-nf-parameters.title"></a><h3 class="sectionTitle">3.3.5.1. Parameters<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	    The next step is to pass in some variables, and it is pretty easy to do. Simply declare the 	    variables as you would normally do for any <tt class="monospace">ferite</tt> script. When you get inside of the function,	    the values passed in will be converted to units that are workable in C with the same name. Complex 	    objects will  be presented to you in the form of pointers to different types of structs according to their	    type. All variables are available by the names you gave in the function declaration. Following 	    is a quick breakdown of the different types and how they convert. </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para">number - Numbers are converted to doubles because doubles can represent LONG_MAX,		and <tt class="monospace">ferite</tt> numbers support floating point values anyways. If you expected to use		the value as an integer in your function you can simply cast the double to a long. 		It is a good idea to check that the number passed in is not greater then LONG_MAX 		before you cast it to an long, otherwise you might end up with some funny looking 		results. </p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">string - Strings are converted to FeriteString *, and their C-string values are 		accessible by struct element 'data'. So you can retrieve the value of string mystring 		by mystring-&gt;data. Following is an example that accesses a string's value by using 		it in a call to <tt class="monospace">strdup</tt>.	      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">native function foo( string mystring ){
    char *mystring_copy = strdup( mystring-&gt;data );
    int length = mystring-&gt;length;
}</pre></td></tr></table></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">object - Objects are instances of classes and represented within C code as FeriteObject's, 	    which must be accessed by reaching into 		<tt class="monospace">ferite</tt>'s internals. This is covered in the next section "Accessing Ferite Internals".	    </p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">array - Arrays are represented by a FeriteUnifiedArray* and must also be accessed by reaching into	    <tt class="monospace">ferite</tt>'s internals. 	    </p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">void - A void variable has no conversion and the name is just a pointer to a variable.	    </p></p></li></ul><p class="para">	       The example below illustrates what builder generates given a the function given.	    </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br /></pre></td><td><pre class="code-linesright">native function example( number x, string s, object o, array a, void v ) 
{
    printf( "Value of x: %f\n", x );
    printf( "String contents: %s\n", s-&gt;data );
    printf( "Object reference count: %d\n", o-&gt;refcount );
    printf( "Array size: %d\n", a-&gt;size );
    printf( "Type: %d\n", v-&gt;type );
}</pre></td></tr></table><p class="para"> This is the C code that is generated: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br /></pre></td><td><pre class="code-linesright">FE_NATIVE_FUNCTION( ferite_module_example_nsoav )
{
   double x;
   FeriteString *s;
   FeriteObject *o;
   FeriteUnifiedArray *a;
   FeriteVariable *v = params[4];
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 5, &x, &s, &o, &a, NULL );

   { /* Main function body. */
#line 5 "test.fec"
 
        printf( "Value of x: %f\n", x );
        printf( "String contents: %s\n", s-&gt;data );
        printf( "Object reference count: %d\n", o-&gt;refcount );
        printf( "Array size: %d\n", a-&gt;size );
        printf( "Type: %d\n", v-&gt;type );
&nbsp;&nbsp;&nbsp;&nbsp;
   }
   FE_RETURN_VOID;
   self = NULL;
}</pre></td></tr></table><p class="para"> The important point being made with this example is how the parameters            are automatically converted from FeriteVariable*s to their real types. This             makes writing native functions much easier. </p></blockquote><a name="cnm-bfc-nf-return-values"></a><a name="cnm-bfc-nf-return-values.title"></a><h3 class="sectionTitle">3.3.5.2. Return Values<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	    Now that we have discussed handling parameters, next you need to know how to return values from 	    functions. Any time you don't specify a return value and your function runs off the end of its 	    scope, <tt class="monospace">builder</tt> will assume you meant to return void and will automatically insert a call to	    return nothing. This can been seen in the previous example, where, at the end of the generated	    code, the following can be seen: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">FE_RETURN_VOID;</pre></td></tr></table><p class="para">	    If returning void is not the desired effect,	    or you would like to specify a position to return from other than running off the end of the	    function's scope, you will need to specifically return a value using one of the following C macros.	    The macros are designed to take a value from the C code, wrap it up into a FeriteVariable, do	    a little house keeping and then return from the function.	  </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_VOID</tt> - returns void to the caller, this is synonymous with not returning		anything.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_TRUE</tt> - returns true to the caller.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_FALSE</tt> - returns false to the caller.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_LONG( value )</tt> - returns a number to the caller with the contents of the		given long.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_DOUBLE( value )</tt> - returns a number to the caller with the contents of the		given double.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_STR( string, freeme )</tt> - returns a FeriteString* to the caller. The parameter		"string" is passed in as a FeriteString*. If freeme == FE_TRUE, string is freed using <tt class="monospace">ferite</tt>'s memory 		manager. if freeme == FE_FALSE, it is not freed at all.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_CSTR( string, freeme )</tt> - returns a char* to the caller. The parameter		"string" is passed in as a char*. If freeme == FE_TRUE, string is freed using <tt class="monospace">ferite</tt>'s memory 		manager. if freeme == FE_FALSE, it is not freed at all.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_ARRAY( pointer to array )</tt> - returns an array to the caller.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_OBJ( pointer to object )</tt> - returns an object to the caller (objects are		instances of classes).</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_NULL_OBJECT</tt> - returns a null object to the caller (useful for functions that		are expected to return an object, but need to signify an error condition).</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FE_RETURN_VAR( variable )</tt> - returns a FeriteVariable to the caller. This allows you to		return a variable that you have created yourself to the engine. It will tag the 		variable allowing <tt class="monospace">ferite</tt> to clear it up when it is finished with. If you want to 		return a variable, but keep hold of it, you must simply return the variable as you 		would an item from a normal c function. eg:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">return someVar;</pre></td></tr></table></p></li></ul><p class="para">	    All of these macros actually convert the given return values into a FeriteVariable * which is then	    returned to the caller. As a general rule, you should always use the available macros when mixing C and	    <tt class="monospace">ferite</tt> to prevent your functions from breaking if the interface ever changes. These macros will be kept	    up to date, so you are safe to use them. All the macros tag the variable they create as being disposable;	    this is a delayed deletion mechanism that gives <tt class="monospace">ferite</tt> permission to free up the variables it has	    finished using. This is important to note, especially with <tt class="monospace">FE_RETURN_VAR</tt> because	    you may not want the variable cleaned up. </p></blockquote><a name="cnm-bfc-nf-finally"></a><a name="cnm-bfc-nf-finally.title"></a><h3 class="sectionTitle">3.3.5.3. And Finally<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	    The previous few sections should give you enough information to get you up on your feet and writing	    native functions. To play with <tt class="monospace">ferite</tt>'s internals you will need to read on where this is dicussed	    in depth. However, here is an example:	  </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br /></pre></td><td><pre class="code-linesright">uses "Example.lib";

namespace Example {
    native function Add( number left, number right ) {
        FE_RETURN_DOUBLE( left + right );
    }
    native function Error( number code, string error ) {
        fprintf( stderr, "Error: %d: %s\n", (int)code, error-&gt;string );
        FE_RETURN_LONG(-1);
    }
}</pre></td></tr></table></blockquote></blockquote><a name="nfc-bnm-classes-and-namespaces"></a><a name="nfc-bnm-classes-and-namespaces.title"></a><h3 class="sectionTitle">3.3.6. Classes and Namespaces<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  Classes and namespaces in native modules are created exactly like their non-native counterparts. You simply declare 	  the namespace or class in the ferite-c file, and when a script tells <tt class="monospace">ferite</tt> to import the module, <tt class="monospace">ferite</tt> will 	  parse the .fec and create the namespaces and classes as usual and link up the native functions from the shared 	  object. There is absolutely no syntax change for creating classes and namespaces. Pretty straight forward isnt it?</p><p class="para">	  There is, however, the added ability to place native functions within classes and namespaces. The syntax for 	  doing so is no different that what you've already seen, just place them within the curly braces of the namespace 	  or class that you would like them to be a part of.	</p><p class="para">Here is an example of a native function in a namespace:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">namespace foo {
    native function bar() {
        <i class="emphasis">...your code goes here...</i>
    }
}</pre></td></tr></table><p class="para">And here is an example of a native function in a class:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">class foo {
    native function bar() {
        <i class="emphasis">...your code goes here...</i>
    }
}</pre></td></tr></table><p class="para">	  You can also make functions in classes static, as was described in the user manual. So of course we can make 	  those native functions as well. Simply place the keyword static in the function declaration.	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br /></pre></td><td><pre class="code-linesright">class foo{
    static native function bar1(){
        <i class="emphasis">...your code goes here...</i>
    }
    native static function bar2(){
        <i class="emphasis">...your code goes here...</i>
    }
}</pre></td></tr></table><p class="para">	  Both bar1() and bar2() are native functions that are static within the class foo. The order of the keywords 	  does not matter.	</p><a name="nfc-bnm-cn-odata"></a><a name="nfc-bnm-cn-odata.title"></a><h3 class="sectionTitle">3.3.6.1. Self Data<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	    When a native function belonging to an object, or namespace or class, is called, there is the <tt class="monospace">self</tt>	    variable available. This is a pointer to the FeriteObject/FeriteClass/FeriteNamespace which is 	    currently executing. Now, to	    make life easier there is a part of the structure that allows you, the module writer,	    to attach any data to it. This is called (and refered to) as <tt class="monospace">odata</tt> and is	    short for object data. <tt class="monospace">ferite</tt> does not and will never touch this. It is the job of the programmer	    to deal with it. It is very simple to use, simply access the odata member on self. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">self-&gt;odata = get_some_resource();</pre></td></tr></table><p class="para">	    Example: In the 'filesystem' module, odata is used to store a pointer to the FILE* pointer for file streams.	  </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">#define SelfObj (FILE*)(self-&gt;odata)</pre></td></tr></table></blockquote></blockquote><a name="nfc-bnm-finally"></a><a name="nfc-bnm-finally.title"></a><h3 class="sectionTitle">3.3.7. Finally<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  This section should have helped you get off your feet and understand the way in which <tt class="monospace">builder</tt> can help	  you not only rapidly develop modules but keep them very close to <tt class="monospace">ferite</tt> code. You should look at the <tt class="monospace">.fec</tt> files that ship with <tt class="monospace">ferite</tt> to clarify any doubts you have.</p></blockquote></blockquote><a name="cnm-without-builder"></a><a name="cnm-without-builder.title"></a><h2 class="sectionTitle">3.4. Without Builder<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	The natural flow of this document means that creating native modules without <tt class="monospace">builder</tt> should be dicussed here.	As most of the dicussion requires knowledge dicussed in the next section, this will be left until after the	internals of <tt class="monospace">ferite</tt> have been looked at. </p></blockquote></blockquote> <hr class="sectionSplitter" /><a name="accessing-ferite-internals"></a><a name="accessing-ferite-internals.title"></a><h1 class="sectionTitle">4. Accessing Ferite Internals<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><a name="afi-introduction"></a><a name="afi-introduction.title"></a><h2 class="sectionTitle">4.1. Introduction<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	This section is designed to teach you how to access, modify, create, and destroy various structures within 	<tt class="monospace">ferite</tt>. It covers variables, functions, classes, and namespaces. It will first cover	very basic memory management, then cover variables, namespaces, calling functions, calling object and class functions,	and creating a class.      </p><p class="para">	It should be noted that this section will cover the registering and accessing of methods, but won't tell you	how to write one from scratch manually. That will be left for the next section where native modules by hand	will be dicussed.      </p></blockquote><a name="afi-ferite-memory-manager"></a><a name="afi-ferite-memory-manager.title"></a><h2 class="sectionTitle">4.2. The Memory Manager<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	Under normal operation <tt class="monospace">ferite</tt> uses its 	own memory manager, which is basically a sub allocator, to achieve some significant performance gains over the	standard malloc/free operations. This memory manager is used throughout <tt class="monospace">ferite</tt>, and the data that is passed around 	in <tt class="monospace">ferite</tt> is expected to be allocated under this manager. The rule of thumb is that any memory that touches ferite	should be obtained from ferite or placed in the odata part, otherwise, it is more than likely that <tt class="monospace">ferite</tt> will	try and free some memory and crash. </p><p class="para">	This memory manager acts much like malloc/free in terms of how you use it. There are functions that mirror 	the malloc, calloc, realloc, and free calls.       </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para">fmalloc( size )</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">fcalloc( size, blocksize )</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">frealloc( ptr, size )</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">ffree( ptr )</p></p></li></ul><p class="para">	These functions all act like the functions they replace. However, they are different so don't mix calls on memory between 	malloc/free and fmalloc/ffree. They play well in the same sand-box, but don't ask them to swap Tonka trucks with 	each other.      </p></blockquote><a name="afi-variables"></a><a name="afi-variables.title"></a><h2 class="sectionTitle">4.3. Working With Variables<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><a name="afi-accessing-variables-meta-data"></a><a name="afi-accessing-variables-meta-data.title"></a><h3 class="sectionTitle">4.3.1. Accessing a Variable's Data<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para"><tt class="monospace">ferite</tt> internally represents all variables using 	  FeriteVariable *'s, and they represent any native type within <tt class="monospace">ferite</tt>. <tt class="monospace">builder</tt>, and the 	  return macros you've already seen are in place to perform conversions for the sake of convenience. But 	  sometimes you just need to stick your fingers in the pudding and get dirty.	</p><p class="para">	  There are a few bits of general information you can get from a FeriteVariable * without looking specifically 	  into on variable type. The internal variable name is accessible (it is a null terminated C string) and usually 	  the variable name has been automatically generated by an operator or a function. It's main use within the engine	  is to store the hash key the variable has within an array. But if you'd really like to have it, you can access is by: 	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">var-&gt;name</pre></td></tr></table><p class="para">	  Much more useful than the variable name is the variable type. This will tell you if the data held is a number (and what	  kind), a <tt class="monospace">ferite</tt> string, an object, an array, a class, namespace, or void (nothing at all). It is accessible by:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">var-&gt;type</pre></td></tr></table><p class="para">It is an integer that can be any one of the following values:</p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_VOID</tt> - a void variable, no value.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_LONG</tt> - a number variable as a C long.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_DOUBLE</tt> - a number variable as a C double.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_STR</tt> - a string variable.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_UARRAY</tt> - an unified array variable.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_OBJ</tt> - an object.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_CLASS</tt> - a class.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_NS</tt> - a namespace.</p></p></li></ul><p class="para">	  There are a number of additional macros available for accessing the actual data within different variable types.	  You should use these macros as much as possible when working with <tt class="monospace">ferite</tt> variables. Internal structures may change,	  but these macros should always be up to date and provide exactly the same semantics when it comes to value access.</p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_VOID</tt> - since this is a void variable, there really isn't any data to	      gain access to.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_LONG</tt> - the data can be accesses by VAI( var ) . This will make it	      act exactly like a C long. You can read its value and set new values.</p><p class="para">Example:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">VAI(mynum) = 7;</pre></td></tr></table></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_DOUBLE</tt> - the data can be accessed by VAF( var ). This will make 	      it act exactly like a c double. You can read its value and set new values.</p><p class="para">Example:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">VAF(mynum) = 8.16;</pre></td></tr></table></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_STR</tt> - using the VAS( var ) macro will get you a FeriteString*, 	      which can then be used in API functions to perform various operations. You can access the string's length 	      and data by using the original FeriteVariable * in the FE_STRLEN( var ) and FE_STR2PTR( var ) macros, 	      respectively. FE_STR2PTR behaves like a char*, and FE_STRLEN behaves like an int. Whenever you change a 	      string's content, you must always update its internal size to reflect the new actual size.</p><p class="para">Example:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">ffree(FE_STR2PTR(var));
FE_STR2PTR(var) = fstrdup("My new string!");
FE_STRLEN(var) = strlen(FE_STR2PTR(var));</pre></td></tr></table><p class="para">	      There are a whole host of functions within the <tt class="monospace">ferite</tt> engine for manipulating FeriteString*'s allowing	      you to do comparisons and replacements on the strings. It should also be noted that FeriteString*'s are	      designed to hold binary data. </p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_OBJECT</tt> - using the macro VAO( var ) will get you a FeriteObject*, 	      which can then be used in a variety of API functions to access variables and functions within that object. </p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_UARRAY</tt> - using the macro VAUA( var ) will get you a 	      FeriteUnifiedArray *, which can then be used in the unified array API functions to add, retrieve and remove 	      values from the array.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_CLASS</tt> - using the macro VAC( var ) will get you a FeriteClass*, 	      which can then be used in a variety of API functions to access variables and functions within that class.	      To get a class passed into a function you must, currently, use the <tt class="monospace">void</tt> type. </p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_NS</tt> - using the macro VAN( var ) will get you a FeriteNamespace*, 	      which can then be used in a variety of API functions to access variables and functions within that namespace.	      To get a class passed into a function you must, currently, use the <tt class="monospace">void</tt> type. </p></p></li></ul></blockquote><a name="afi-changing-variables-type"></a><a name="afi-changing-variables-type.title"></a><h3 class="sectionTitle">4.3.2. Changing a Variable's Type<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  To change a variable from one type to another you need to call the function 	  <tt class="monospace">ferite_variable_convert_to_type</tt>. This takes the script, the variable to change and the new	  type that you require. The function will take care of any arrays, objects etc that may still be attached to the	  variable. For example, to change a double to a long, you can simply do this:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br /></pre></td><td><pre class="code-linesright">ferite_variable_convert_to_type( script, var, F_VAR_LONG );
VAI(var) = 10;</pre></td></tr></table><p class="para">	  And to change it back:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br /></pre></td><td><pre class="code-linesright">ferite_variable_convert_to_type( script, var, F_VAR_DOUBLE );
VAF(var) = 10.0;</pre></td></tr></table><p class="para">	  It is considered bad for you to simply change the type of a variable. It is not encouraged at all. It is therefore	  on your own head to keep things correct.	</p></blockquote><a name="afi-creation-and-deletion-of-variables"></a><a name="afi-creation-and-deletion-of-variables.title"></a><h3 class="sectionTitle">4.3.3. Creating and Destroying Variables<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  Creating variables is quite simple: each variable type has a 'create' function that returns a FeriteVariable*. 	  You already know how to manipulate these variables (or at least get 	  to the information needed to manipulate them), so I'll just quickly run through the variable types available, and 	  their creation functions. The parameters should be pretty self-explanitory, if not please refer the the C API 	  document. It should be noted though that they all take the same argument "alloc." This tells <tt class="monospace">ferite</tt> whether or 	  not the name of the variable should be allocated or whether it is static; You should state that the name is static	  if you are passing a string constant so that ferite wont waste memory. E.g.</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br /></pre></td><td><pre class="code-linesright">char *name = strdup("SomeName");
FeriteVariable *copy_name = 
    ferite_create_number_long_variable( name, 42, FE_ALLOC );
FeriteVariable *ref_name = 
    ferite_create_number_long_variable( "SomeName", 42, FE_STATIC );
free(name);</pre></td></tr></table><p class="para"> In the above example, the first allocation of the variable causes <tt class="monospace">ferite</tt> to copy the name, allowing        the <tt class="monospace">name</tt> variable to be free'd up. The second variable allocation tells ferite to        retain a reference to the name because we know it wont be cleared up. </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_VOID</tt> - FeriteVariable *ferite_create_void_variable(char *name, int alloc);</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_LONG</tt> - FeriteVariable *ferite_create_number_long_variable(char *name, long data, int alloc);</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_DOUBLE</tt> - FeriteVariable *ferite_create_number_double_variable(char *name, double data, int alloc);</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_STR</tt> - FeriteVariable *ferite_create_string_variable(char *name, FeriteString *data, int alloc);</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_STR</tt> - FeriteVariable *ferite_create_string_variable_from_ptr(char *name, char *data, int length, int encoding, int alloc);	      Currently, the encoding value is always <tt class="monospace">FE_CHARSET_DEFAULT</tt>. The reason for it being	      set now is so the in the future when the encoding of a string is important code will still work unmodified.</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_UARRAY</tt> - FeriteVariable *ferite_create_uarray_variable(char *name, int size, int alloc);</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_OBJ</tt> - FeriteVariable *ferite_create_object_variable( char *name, int alloc );</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_CLASS</tt> - FeriteVariable *ferite_create_class_variable( FeriteScript *script, char *name, FeriteClass *klass, int alloc )</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">F_VAR_NS</tt> - FeriteVariable *ferite_create_namespace_variable( FeriteScript *script, char *name, FeriteNamespace *ns, int alloc )</p></p></li></ul><p class="para">	  To delete any <tt class="monospace">ferite</tt> variable, 	  you use the <tt class="monospace">ferite_variable_destroy</tt> function. This function takes the current script and a 	  FeriteVariable * as parameters, and it returns void.</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">void ferite_variable_destroy( 
    FeriteScript *script, 
    FeriteVariable *var );</pre></td></tr></table><p class="para">	  You can use this function on any type of variable. Each will be handled in the appropriate manner according to its 	  type. Strings will have their C string data freed by <tt class="monospace">ffree</tt> and will then be destroyed. 	  Objects will have their	  destructor called before they are destroyed. Lastly, unified arrays will have the variables at each of its indexes 	  destroyed in the appropriate manner according to their type and will then, themselves, be destroyed.</p></blockquote></blockquote><a name="afi-working-with-namespaces"></a><a name="afi-working-with-namespaces.title"></a><h2 class="sectionTitle">4.4. Working With Namespaces<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	In this section we'll cover how to create and delete namespaces, and how to create, 	access, and delete variables and how to register and delete functions, and how to find things within them. 	Namespaces are created by registering them within the script. This can be done with the following function:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteNamespace *ferite_register_namespace( 
    FeriteScript *script, 
&nbsp;&nbsp;&nbsp;&nbsp;char *name, 
&nbsp;&nbsp;&nbsp;&nbsp;FeriteNamespace *parent )</pre></td></tr></table><p class="para">	The function takes three parameters: the script to register the namespace into, the name of the namespace	you wish to create, and the parent where you wish to create the new namespace. The parent must be a valid pointer to a	FeriteNamespace, you can either find one with <tt class="monospace">ferite_find_namespace</tt>, or you can simply use script-&gt;mainns 	to use the top-level namespace of a script as the parent. If the register is successful, the FeriteNamespace * 	that refers to the new namespace is returned. The data it points to is internally allocated, so do not destroy 	it. If the register failed, it will return NULL.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">module-init {
    FeriteNamespace *mobile = 
        ferite_register_namespace( script, 
                    "Mobile", script-&gt;mainns );
}</pre></td></tr></table><p class="para">	Once you have a namespace created, you can delete it with this function:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">int ferite_delete_namespace( FeriteScript *script, FeriteNamespace *ns )</pre></td></tr></table><p class="para">	This will destroy the namespace after recursivly destroying all of its children. This includes all variables, 	sub-namespaces, classes and functions. It currently always returns 1.      </p><p class="para">	Creating and deleting namespaces is only fun for a short while. Eventually you'll want to put variables into 	your new namespace, and probably functions and classes as well. The next three functions will allow you to do	just that.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteVariable *ferite_register_ns_variable( 
                    FeriteScript *script, 
                    FeriteNamespace *ns, 
                    FeriteVariable *var )</pre></td></tr></table><p class="para">	This will register a variable into the namespace that you provide. If you've recently created the namespace, you can	use the FeriteNamespace * that the register function returned. Otherwise you will have to look up the FeriteNamespace *	to the namespace you wish to place your variable in using the ferite_find_namespace function. The value returned is	always the same as the value passed in as the var parameter. The variable will be accessible under the new namespace according	to its name stored in the FeriteVariable struct. So you might want to make sure you set it to something intelligent before	you register it into a namespace. E.g.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br /></pre></td><td><pre class="code-linesright">module-init {
    FeriteNamespace *mobile = 
        ferite_register_namespace( script, 
                                   "Mobile", 
                                   script-&gt;mainns );
    FeriteVariable *signal = ferite_create_number_long_variable( 
                                   "signal", 
                                   0, 
                                   FE_STATIC );
    ferite_register_ns_variable( script, mobile, signal );
}</pre></td></tr></table><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteFunction *ferite_register_ns_function( 
                    FeriteScript *script, 
                    FeriteNamespace *ns, 
                    FeriteFunction *f )</pre></td></tr></table><p class="para">	This functions registers a function into the given namespace. The return value is always the same as the value passed 	in as the f parameter. Again, the name of the element comes from the name field of the FeriteFunction struct. Set it 	before you register the function.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteClass *ferite_register_ns_class( 
                    FeriteScript *script, 
                    FeriteNamespace *ns, 
                    FeriteClass *klass )</pre></td></tr></table><p class="para">	This will register a class into the given namespace. The return value is always the same as the value passed in as the 	klass parameter. Once again, the name of the element comes from the name field of the FeriteClass struct. Set the name	before you register the class. Most of the time you will never use this as the standard way to create a class will also	automatically register it, it is merely mentioned here for completness.      </p><p class="para">	The next logical step is gaining access to variable, functions, and classes that are registered to namespaces. This is 	done by retrieving a <tt class="monospace">FeriteNamespaceBucket</tt> which contains the information you desire in its data 	element. The following function is used for retrieving these buckets: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">FeriteNamespaceBucket *ferite_find_namespace( 
                    FeriteScript *script, 
                    FeriteNamespace *parent, 
                    char *obj, 
                    int type )</pre></td></tr></table><p class="para">	This will return a FeriteNamespaceBucket * on success, or NULL on failure. It takes a script, and a starting point as 	the first two parameters. The third parameter is the dot-delimited name of the object you are looking for, relative to 	the parent namespace given. So if you are using the root namespace (script-&gt;mainns) as your parent namespace, and wish 	to access mynamespace.myothernamespace.myvar, then you would pass "mynamespace.myothernamespace.myvar" as the third parameter. 	However, if you already have a FeriteNamespace * that refers to 'mynamespace', then you could pass that in as the parent 	(2nd parameter) and then access myvar by passing "myothernamespace.myvar" as the obj (3rd parameter). Lastly, if you 	already have the FeriteNamespace * for 'myothernamespace', then you would simply pass "myvar" as the obj. Because you are 	only dealing with one level of depth, you do not place a period within the obj in that instance. The fourth, and last, 	parameter is the type of object you are looking for. It is always one of the following defined types:      </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FENS_NS</tt> - retrieves namespaces</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FENS_VAR</tt> - retrieves variables</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FENS_FNC</tt> - retrieves functions</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para"><tt class="monospace">FENS_CLS</tt> - retrieves classes</p></p></li></ul><p class="para">	If you choose to pass 0 to the function, you will get back the named FeriteNamespaceBucket if it exists. Using the 	above defines allows you to tell ferite_find_namespace what type of bucket you are looking for guaranteeing that what 	you get back is the correct item and type.      </p><p class="para">	Again, once you have the bucket, you can access the desired value by looking in the data element. Example:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br /></pre></td><td><pre class="code-linesright">FeriteVariable *myvar = NULL;
FeriteNamespaceBucket *nsb = NULL;

nsb = ferite_find_namespace(script, 
    script-&gt;mainns, 
    "mynamespace.myvar", FENS_VAR);

if( NULL != nsb ){ /* we found it! */
    myvar = (FeriteVariable *) nsb-&gt;data;
    /* we needed to cast because nsb-&gt;data is a void* type */
}</pre></td></tr></table><p class="para">	At this point I can use myvar just like any other FeriteVarible *, because it is one! When the value of this variable is	changed it will be noticable straight away within the script. It is also important to note that you must not take these	variables you have obtained and return them to the script via FE_RETURN_VAR. This will cause <tt class="monospace">ferite</tt> to delete the variable	and leave dangling pointers. If you wish to return the variable simply return it like you would a normal c variable: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">return myvar;</pre></td></tr></table><p class="para">	To get a function is the same process. Example:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br /></pre></td><td><pre class="code-linesright">FeriteFunction *func = NULL;
FeriteNamespaceBucket *nsb = NULL;

nsb = ferite_find_namespace( script, 
    script-&gt;mainns, 
    "mynamespace.function", 
    FENS_FNC );

if( NULL != nsb ){
    func = (FeriteFunction*)nsb-&gt;data;
    ....
}</pre></td></tr></table><p class="para">	It is good to note that within <tt class="monospace">ferite</tt>'s source, the convention is to call the namespace bucket variable 'nsb'.      </p><p class="para">	As promised at the beginning of this section, here is how to unregister elements from namespaces:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">void ferite_delete_namespace_element_from_namespace( 
                    FeriteScript *script, 
                    FeriteNamespace *ns, 
                    char *name )</pre></td></tr></table><p class="para">	This will delete the element name from the namespace ns within the script script. Be careful though, this 	function will not burrow down layers of namespaces to find the element you specify. So you cannot use the dot 	notation here, this is a deliberate design choice to stop accidental deletion of the wrong elements. You must 	first find the immediate parent of the element (using ferite_find_namespace), and pass that in as the namespace 	ns. You can use this to delete namespaces from within namespaces as well, and in that case it will also recursively 	destroy the deleted namespace's contents.      </p><p class="para">	So that is all there really is to namespaces. They are an excellent form of container both in and out of scripts!      </p></blockquote><a name="afi-working-with-objects-and-classes"></a><a name="afi-working-with-objects-and-classes.title"></a><h2 class="sectionTitle">4.5. Working With Objects And Classes<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><a name="afi-wwoc-creation"></a><a name="afi-wwoc-creation.title"></a><h3 class="sectionTitle">4.5.1. Creating Classes<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  Registering classes is much the same as registering namespaces. You first register the class, then you add	  the variables and functions you wish to publish in them.	</p><p class="para">	  To register a class you use the ferite_register_inherited_class function call.	  This will create the class, setup the inheritence, register the class wihin a	  namespace for you and return it in one fell swoop.	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">FeriteClass *ferite_register_inherited_class( 
                    FeriteScript *script, 
                    FeriteNamespace *ns, 
                    char *name, 
                    char *parent )</pre></td></tr></table><p class="para">	  The first parameter is the script, the second is the namespace in which you want	  to place the class, the third is the name of the class by which programmers can	  reference it and the fourth is the name of the class the new class inheirts	  from. The fourth argument can be in standard dot notation and is the name of the	  parent class. For instance, it could be "Sys.Stream". The function will start	  looking for the class in the namespace that is passed to the function, and then	  start in the top level script namespace.	  For instance, if the "Sys" namespace was passed to the function, you would want to specify "Stream".	  If you do not wish for your class to inherit from any existing class simply pass NULL and	  the new class will be automatically placed as a subclass of the base class	  "Obj".	</p><p class="para">	  Registering variables and functions with a class is much the same as registering	  them with a namespace, you simply pass an extra parameter to say whether or not	  the item is static (linked to the class) or an instance variable (linked to the	  object created from the class).	</p><p class="para">	  To add a variable you call:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">int ferite_register_class_variable( 
                    FeriteScript *script, 
                    FeriteClass *klass, 
                    FeriteVariable *variable, 
                    int is_static )</pre></td></tr></table><p class="para">	  The second argument is the class to add the variable to. The class can be obtained	  from creating a new class or pulling one out of a namespace. The third argument	  is the variable to add. The fourth variable is whether or not the variable	  is static.	</p><p class="para">	  To add a function you call:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">int ferite_register_class_function( 
                    FeriteScript *script,
                    FeriteClass *klass, 
                    FeriteFunction *f, 
                    int is_static )</pre></td></tr></table><p class="para">	  The arguments are almost identical except for the third one which is a pointer	  to a <tt class="monospace">ferite</tt> function.</p></blockquote><a name="afi-wwoc-object-creation"></a><a name="afi-wwoc-object-creation.title"></a><h3 class="sectionTitle">4.5.2. Creating Objects<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  Creating objects is very straight forward. There are two main method calls that	  can be used. 	</p><p class="para">	  The first is <tt class="monospace">ferite_build_object</tt>. Its pupose is to simply	  allocate a FeriteVariable*, allocate the necessary structures (such as it's instance variables,	  and pointers to functions) and add it to the <tt class="monospace">ferite</tt> garbage collector. <tt class="monospace">ferite_build_object</tt> does <strong class="strong">not</strong> call the new object's	  constructor. This is very useful for when you are doing manual setup of an object.	  The prototype for the function is:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">FeriteVariable *ferite_build_object( 
                    FeriteScript *script, 
                    FeriteClass *nclass )</pre></td></tr></table><p class="para">	  The second is <tt class="monospace">ferite_new_object</tt> which does all the same things <tt class="monospace">ferite_build_object</tt> does except it will call the constructor for the	  new object. It will return an FeriteVariable* that is ready to be cleaned up by <tt class="monospace">ferite</tt>	  as and when it is returned to the engine and no longer wanted. It has the prototype:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteVariable *ferite_new_object( 
                    FeriteScript *script, 
                    FeriteClass *nclass, 
                    FeriteVariable **plist )</pre></td></tr></table><p class="para">	  The first two arguments are the same for <tt class="monospace">ferite_build_object</tt>, the current	  script and the class you wish to instantiate. The third argument is the parameter list to be	  passed to the object's constructor. Read the next section on calling functions to find out how	  to create one and what they consist of.	</p></blockquote><a name="afi-accessing-variables"></a><a name="afi-accessing-variables.title"></a><h3 class="sectionTitle">4.5.3. Accessing Variables<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  Firstly, we'll cover how to access variables within objects and classes. It is	  done essentially the same way for each. Both FeriteClass and FeriteObject	  structs have a variables element that is a hash of all variables within them. To	  make life slightly easier and code more understandable there are a couple of	  functions for retrieving the variables from either a class or an object.	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteVariable *ferite_object_get_var( 
                    FeriteScript *script, 
                    FeriteObject *object, 
                    char *name )</pre></td></tr></table><p class="para">	  This is for getting the value out of an object. It should be noted that the	  second argument is not a FeriteVariable* but a FeriteObject*. This means that is	  it necessary, if you have a FeriteVariable* pointing to an object, to call it with 	  VAO(nameOfVariable).	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteVariable *ferite_class_get_var( 
                    FeriteScript *script, 
                    FeriteClass *klass, 
                    char *name )</pre></td></tr></table><p class="para">	  Both the above functions take the name of the variable to obtain and will return	  a pointer to the variable if it exists, or will return NULL if it doesn't.	</p><p class="para">	  For example, for objects you would do this: (assume that some_object is of type FeriteVariable *, and it is a 	  valid object)	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">FeriteVariable *myvar = ferite_object_get_var(script, 
                                              VAO(some_object), 
                                              "myvar");</pre></td></tr></table><p class="para">	  If myvar is not NULL, then it was successfully retrieved. If you want to do the	  same with a class, you do this: (assume that some_class is of type FeriteClass *, and it is a valid class)	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">FeriteVariable *myvar = ferite_class_get_var(script, 
                                             some_class, 
                                             "myvar");</pre></td></tr></table><p class="para">	  Again, if myvar is not NULL, it was successfully retrieved.	</p></blockquote><a name="afi-accessing-functions"></a><a name="afi-accessing-functions.title"></a><h3 class="sectionTitle">4.5.4. Accessing Functions<a href="#toc"><img border="0" src="http-int.png" /></a></h3><blockquote class="section"><p class="para">	  Getting functions from objects or classes is easy if you can get a variable from them (Hint: make sure	  you read the last section!).	</p><p class="para">	  To get your hands on a function in an object you simply use the function call <tt class="monospace">ferite_object_get_function</tt>.	  Suprised? You shouldn't be. It looks, feels and tastes very similar to <tt class="monospace">ferite_object_get_var</tt>	  except this time you get a function not a variable.	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteFunction *ferite_object_get_function( 
                    FeriteScript *script, 
                    FeriteObject *object, 
                    char *name );</pre></td></tr></table><p class="para">	  To get your hands on a function tucked away in a class you simply need to use the function call 	  <tt class="monospace">ferite_class_get_function</tt>. 	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteFunction *ferite_class_get_function( 
                    FeriteScript *script, 
                    FeriteClass *cls, 
                    char *name )</pre></td></tr></table></blockquote></blockquote><a name="afi-calling-functions"></a><a name="afi-calling-functions.title"></a><h2 class="sectionTitle">4.6. Calling Functions<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	  Once you have a FeriteFunction *, the next thing you're probably going to want	  to do is call the function it to which it refers. This is one of the trickier	  things to do in <tt class="monospace">ferite</tt>, but only because it involves several stages in order to	  complete.	</p><p class="para">	  Firstly, you need your FeriteFunction *, which can be obtained by using the	  ferite_find_namespace function. Then you'll need to create a parameter list	  that you wish to pass to the function. This is done with the following function:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteVariable **ferite_create_parameter_list_from_data( 
                    FeriteScript *script, 
                    char *format, 
                    ... );</pre></td></tr></table><p class="para">	  This function does its best to make creating parameter lists simple. The first	  parameter is the script, the second is a format string that describes the types	  of variables that will make up the argument list, and the rest of the parameters are the	  values to be used as described by the format string. The format string must be zero or more of	  the following:	</p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para">n - a number, the value passed must be a C variable of type double</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">l - a number, the value passed must be a C variable of type long</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">s - a string, the value passed must be a pointer to FeriteString</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">o - an object, the value passed must be a pointer to a FeriteObject</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">a - an array, the value passed must be a pointer to a FeriteUnifiedArray</p></p></li></ul><p class="para">	  The function will return a parameter list (FeriteVariable **) which can then be 	  used as a parameter in the next function to be dicussed. For your information, a parameter list is	  simply a NULL terminated C array of FeriteVariable* - these are easy to create by hand, but 	  this function simply aids the creation.	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br /></pre></td><td><pre class="code-linesright">FeriteVariable *ferite_call_function( 
                    FeriteScript *script, 
                    void *container, 
                    FeriteObject *block, 
                    FeriteFunction *orig_function, 
                    FeriteVariable **params )</pre></td></tr></table><p class="para">	  This function will call the function and return a FeriteVariable *, which will be the returned value of	  the called function. It must be caught and destroyed, or you will leak memory.	  Even functions returning void will return a fully allocated FeriteVariable * of type F_VAR_VOID.	</p><p class="para">	  The first parameter is the script, the second is the pointer to the container of the function, for instance	  for a namespace function a FeriteNamespace, for a class a FeriteClass pointer and an object, a FeriteObject	  pointer. The third argument is the closure that can be passed to the function, this can be NULL. The fourth	  argument is the FeriteFunction you wish to call, and the last is the parameter list you had	  created with the previously described ferite_create_parameter_list_from_data() function. The parameter list	  may be NULL indicating that the function takes no arguments.	</p><p class="para">	  When you are finished with the parameter list, simply delete it with this function:	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">void ferite_delete_parameter_list( 
                    FeriteScript *script, 
                    FeriteVariable **list );</pre></td></tr></table><p class="para">	  So there you have it, three steps to calling another function within <tt class="monospace">ferite</tt>.	  Here is a complete example which calls 'Console.println' with the string 'Hello	  World':	</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br /></pre></td><td><pre class="code-linesright">FeriteFunction *println = NULL;
FeriteVariable **params = NULL;
FeriteVariable *rval = NULL;

/* Create a string to pass to the function */
FeriteString *hello = ferite_str_new( "Hello World", 0, FE_CHARSET_DEFAULT );

/* Find the function in the scripts main namespace */
FeriteNamespaceBucket *nsb = ferite_find_namespace( 
                                    script, 
                                    script-&gt;mainns, 
                                    "Console.println", 
                                    FENS_FNC );
FeriteNamespaceBucket *console = ferite_find_namespace(
                                    script,
                                    script-&gt;mainns,
                                    "Console",
                                    FENS_NS );

if( NULL != nsb ) /* Check to see if we have the function ... */
{
    println = nsb-&gt;data;
    
    /* Create the parameter list */
    params = ferite_create_parameter_list_from_data( script, "s", hello )
    
    /* Call the function */
    rval = ferite_call_function( script, console, NULL, println, params );
    
    /* And finally clear up after ourselves */
    ferite_delete_parameter_list( script, params );
    ferite_variable_destroy( script, rval );
    ferite_str_destroy( script, hello );
}
else    
    /* We don't.. let's print an error! */
    printf( "Cant find 'Console.println'! Is the console module loaded?\n" );</pre></td></tr></table><p class="para">	   The only difference with calling a class or object function compared to that of a namespace	   function is the passing in of the container. There are no other special tricks that are required.	</p></blockquote><a name="afi-errors"></a><a name="afi-errors.title"></a><h2 class="sectionTitle">4.7. Raising Exceptions and Reporting Errors<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	There are times when things go wrong. It's a painful time, but it need not be. Ferite provides a means of raising	exceptions to force a programmer to deal with errors but also a means of quietly setting the error information 	allowing the programmer to check for non-fatal things.      </p><p class="para">	It is considered good form to return error values from a function call. This is the route you should take if you	require the reporting of errors. For instance, if you have a function that connects to a resource and returns an object	to interact with that resource, it makes sense to return a null object (<tt class="monospace">FE_RETURN_NULL_OBJECT</tt>) if	that resource can't be obtained.      </p><p class="para">	Sometimes it is not possible to return an error value. In these situations it is considered good form to use the	function <tt class="monospace">ferite_set_error</tt> [it's prototype is below]. This sets the <tt class="monospace">err</tt> script	object's values, but does not raise an exception. This allows the programmer to ignore things if needs be. It takes	a number of parameters, the first is the script you are running in, the second is the error number and the last is	the format of a string [same as <tt class="monospace">printf</tt>] describing the error that has occured. It should be	documented that this is the case such that the programmer knows what to look for.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">void ferite_set_error( FeriteScript *script, int num, char *fmt, ... );</pre></td></tr></table><p class="para">	When all hope is lost, there are times when an exception needs to be rasied because some has gone completely wrong.	This is done by calling <tt class="monospace">ferite_error</tt>. You can pass it the error number and the message just like	<tt class="monospace">ferite_set_error</tt>.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">void ferite_error( FeriteScript *script, int num, char *fmt, ... );</pre></td></tr></table><p class="para">	Sometimes it is nice to warn people about not so bad things, and as such there is a function <tt class="monospace">ferite_warning</tt>	which will place a warning on the script.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">void ferite_warning( FeriteScript *script, char *errormsg, ... );</pre></td></tr></table></blockquote><a name="executing-code-snippets"></a><a name="executing-code-snippets.title"></a><h2 class="sectionTitle">4.8. Executing Code Snippets<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	Sometimes it is easier to execute a block of code, from within a function, written in <tt class="monospace">ferite</tt>. For this you can use the	eval mechanism. What this does is the same as the <tt class="monospace">eval</tt> operator in <tt class="monospace">ferite</tt>. It will compile and execute	the script and then return the return value of the main function. For example:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">rval = ferite_script_eval( script, "Console.println('Hello World');" );</pre></td></tr></table><p class="para">	You must destroy the return value using <tt class="monospace">ferite_variable_destroy</tt> just as you would a function call. </p></blockquote></blockquote> <hr class="sectionSplitter" /><a name="native-modules-by-hand"></a><a name="native-modules-by-hand.title"></a><h1 class="sectionTitle">5. Native Modules - By Hand<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><p class="para"> The aim of this section is to show you how to write      modules by hand. This section is also very useful for people wanting to embed <tt class="monospace">ferite</tt> as it shows how to export an API by hand. </p><a name="nmbh-functions"></a><a name="nmbh-functions.title"></a><h2 class="sectionTitle">5.1. Functions<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para"><tt class="monospace">builder</tt> makes the following completely	automatic. As with normal C functions, we have to declare our native <tt class="monospace">ferite</tt> functions. This is done in three stages. 	First we declare the function,	then we create our FeriteFunction structure and then we register it with the <tt class="monospace">ferite</tt> engine. To declare the variable, you use 	the macro <tt class="monospace">FE_NATIVE_FUNCTION</tt>,	this is true for both object/class methods and normal namespace functions. This takes one argument, which is the name of the	function you wish to create. After the macro, you simply write the body of your function as you normally would. For example:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FE_NATIVE_FUNCTION( printfnc )
{
    printf( "We are in our native function!\n" );
}</pre></td></tr></table><p class="para"> The next thing we need to do is create a FeriteFunction structure	with which we can register the function (using the functions mentioned in the last section). This is a call to<tt class="monospace">ferite_create_external_function</tt>.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">FeriteFunction *ferite_create_external_function( 
                    FeriteScript *script, 
                    char *name, 
                    void *(*funcPtr)(FeriteScript*,FeriteFunction*,FeriteVariable**), 
                    char *description );</pre></td></tr></table><p class="para">	This takes the current script, the name of the function, a pointer to the function, and its signature description.     The third means you simply pass the name of the native function, eg. in the above example it would be 	<tt class="monospace">printfnc</tt>. The description is slightly more complicated. It is a null terminated string which takes a number	of characters that describe what arguments the function can take.      </p><ul class="list"><li class="listItem"><p class="listItemParagraph"><p class="para">n - number</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">s - string</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">a - array</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">o - object</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">v - void</p></p></li><li class="listItem"><p class="listItemParagraph"><p class="para">. - variable argument list</p></p></li></ul><p class="para">	Each character responds to each type and it allows <tt class="monospace">ferite</tt> to make sure that the function gets passed the correct parameters. 	To make life slighty clearer, here are a few examples with the <tt class="monospace">ferite</tt> function and what would be the equivelent description for a 	native function: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">function ex1( string name, number age ){ } would be "sn"
&nbsp;&nbsp;&nbsp;&nbsp;
function ex2( string format, ... ) { } would be "s."
&nbsp;&nbsp;&nbsp;&nbsp;
function ex3( object res, string query, array args ) { } would be "osa"</pre></td></tr></table><p class="para">	To register the function structure you have, you either use <tt class="monospace">ferite_register_ns_function</tt> or<tt class="monospace">ferite_register_class_function</tt>. You must be aware that you can only register each created	function once! Otherwise <tt class="monospace">ferite</tt> will certainly die when it tries to clean everything up at the end of execution. </p><p class="para">	So, lets assume that our above print function takes a string and a number and prints out the string the number of times	it is told. The example below will show how to declare, create and register a FeriteFunction in a namespace. The example	will also allow us to touch on another couple of important areas.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br /></pre></td><td><pre class="code-linesright">FE_NATIVE_FUNCTION( printfnc ); /* Declare the prototype */
&nbsp;&nbsp;&nbsp;&nbsp;
FE_NATIVE_FUNCTION( printfnc )
{
    FeriteString *print = NULL;
    double countd = 0;
    int i = 0, count = 0;
    
    /* Get the parameters */
    <strong class="strong">ferite_get_parameters( params, 2, &print, &countd );</strong> <i class="emphasis">/* #1 */</i>
    
    /* Loop round printing */
    count = (long)countd;
    for( i = 0; i &lt; count; i++ )
        printf( "%s", print-&gt;data );
    
    <strong class="strong">FE_RETURN_VOID;</strong> <i class="emphasis">/* #2 */</i>
}

void module_init( FeriteScript *script )
{
    /* Create the function */
    FeriteFunction *f = ferite_create_external_function( 
                                script, 
                                "printfnc", 
                                printfnc, 
                                "sn" );
    
    /* Now register it in the main namespace */
    ferite_register_ns_function( script, script-&gt;mainns, f );
}</pre></td></tr></table><p class="para">	Point <i class="emphasis">#1</i> is the main point to be covered.: <tt class="monospace">ferite_get_parameters</tt> is a helper	function for getting the values of the parameters into C variables you can manipulate. It is very	important that you do not delete or free the values you have because they point to the real values.    The first is the parameter list you are given and when writing	the native function, it is always called <tt class="monospace">params</tt>. The second argument is the number of values from	the parameter list that you want. The rest of the arguments are pointers to the local C function variables you wish to set. In our	example above, the address of the <tt class="monospace">print</tt> and <tt class="monospace">countd</tt> variables were passed. This	is exactly how <tt class="monospace">builder</tt> gets the values from the parameter list - it is simply hidden from the programmer. </p><p class="para">	All functions must return something even if it	is just a void. Builder hides <i class="emphasis">#2</i> from you, but when writing functions from scratch, it is important	you remember to return something. </p><p class="para">	To get the number of parameters that were passed to the function, you can use the <tt class="monospace">ferite_get_parameter_count</tt>.	This takes just one argument (<tt class="monospace">params</tt>) and returns the number of variables in it.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">int ferite_get_parameter_count( FeriteVariable **list );</pre></td></tr></table><p class="para"> To get the container of the function passed into it, you should use the following macros: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">#define FE_CONTAINER_TO_OBJECT  (FeriteObject*)__container__
#define FE_CONTAINER_TO_CLASS   (FeriteClass*)__container__
#define FE_CONTAINER_TO_NS      (FeriteNamespace*)__container__</pre></td></tr></table><p class="para"> These are defined in <tt class="monospace">ferite.h</tt> and can be used like follows: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">FE_NATIVE_FUNCTION( toString )
{
    FeriteObject *self = FE_CONTAINER_TO_OBJECT;
    FE_RETURN_CSTR( "Example-toString()", FE_FALSE );
}</pre></td></tr></table></blockquote><a name="nmbh-main-bit"></a><a name="nmbh-main-bit.title"></a><h2 class="sectionTitle">5.2. The Rest<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	All you have to do	to fullfill the requirements of a <tt class="monospace">ferite</tt> module is write four functions. These functions	are the ones that <tt class="monospace">builder</tt> creates for you from <tt class="monospace">module-init, module-deinit, module-register, and
	  module-unregister</tt>.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br /></pre></td><td><pre class="code-linesright">void modulename_register()
{
    <i class="emphasis">/* System wide setup. Called when the 
    module is loaded from disk. */</i>
}
&nbsp;&nbsp;&nbsp;&nbsp;
void modulename_init( FeriteScript *script )
{
    <i class="emphasis">/* Per script setup. This is where you put the 
    code to register namespaces, classes, functions and 
    variables and setup anything the script needs. */</i>
}
&nbsp;&nbsp;&nbsp;&nbsp;
void modulename_deinit( FeriteScript *script )
{
    <i class="emphasis">/* Anything you need to shutdown per script. 
    Ferite will clean up all structures you have registered 
    so you do not need to clean those up yourself [eg. the 
    namespaces you have registered]. */</i>
}

void modulename_unregister()
{
    <i class="emphasis">/* System wide shutdown. This gets called when 
    the ferite engine is being deinitialised. */</i>
}</pre></td></tr></table><p class="para">	If you have these four functions exported from your module, <tt class="monospace">ferite</tt> should find them without problem. One thing to	note: the name of the module <strong class="strong">must</strong> be the same as the prefix for each of the functions	otherwise <tt class="monospace">ferite</tt> will not be able to find them. For instance in <tt class="monospace">foo.lib</tt> the init function	must be called <tt class="monospace">foo_init</tt>.      </p><p class="para">	You may also want to read the next section as a cunning secret is told that can make writing native modules	easier.      </p></blockquote></blockquote> <hr class="sectionSplitter" /><a name="embedding-ferite"></a><a name="embedding-ferite.title"></a><h1 class="sectionTitle">6. Embedding Ferite<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><p class="para"> This section is split into three sub-sections. The first deals with getting the engine up and running within your application      so that scripts can be executed. The second section deals with the most effcient way of exporting the application's      interface into a script so that useful things can then be done. The third is how to cheat with <tt class="monospace">builder</tt> and applications. </p><a name="ef-getting-the-engine-purring"></a><a name="ef-getting-the-engine-purring.title"></a><h2 class="sectionTitle">6.1. Getting The Engine Purring<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	Ferite is designed to be placed in pretty much anywhere. Therefore it is pretty easy to get the engine up	and running, scripts compiled and then executed, and to clean everything up afterwards. To explain how to do	this, an example is listed below and afterwards each line is discussed. It is a simple program that shows	most of the functionality of the <tt class="monospace">ferite</tt> command line program. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br /></pre></td><td><pre class="code-linesright">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ferite.h&gt;
            
int main( int argc, char **argv )
{
    FeriteScript *script;
    char *errmsg = NULL, *scriptfile = "test.fe";

    if( ferite_init( 0, NULL ) )
    {
        ferite_add_library_search_path( XPLAT_LIBRARY_DIR );
        ferite_set_library_native_path( NATIVE_LIBRARY_DIR );
&nbsp;&nbsp;&nbsp;&nbsp;
        script = ferite_script_compile( scriptfile );
        if( ferite_has_compile_error( script ) )
        {
            errmsg = ferite_get_error_log( script );
            fprintf( stderr, "[ferite: compile]\n%s", errmsg );
        }
        else
        {
            ferite_script_execute( script );
            if( ferite_has_runtime_error( script ) )
            {
                errmsg = ferite_get_error_log( script );
                fprintf( stderr, "[ferite: execution]\n%s", errmsg );
            }
        }
        if( errmsg )
          ffree( errmsg );
        ferite_script_delete( script );
        ferite_deinit( );
    }
    exit( 0 );
}</pre></td></tr></table><p class="para">	And now, the explanation. It should be noted that only the lines that are critical to the operation of <tt class="monospace">ferite</tt> will be	dicussed, anything that is standard C will be left out. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br /></pre></td><td><pre class="code-linesright">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ferite.h&gt;</pre></td></tr></table><p class="para">	The above is all pretty standard issue. You dont need the <tt class="monospace">stdio.h</tt> or <tt class="monospace">stdlib.h</tt>	headers to be honest. But with any program they are good practice. The one you do need is <tt class="monospace">ferite.h</tt>.	This will pull all the function prototypes and defines into the program so that the magic may begin. This will ensure that	all the headers that are required to interface with ferite are visible to the compiler.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">if( ferite_init( 0, NULL ) )</pre></td></tr></table><p class="para">	This line initialises the engine. You must do this before you do anything <tt class="monospace">ferite</tt> related. This is because this call will	initialise the <tt class="monospace">ferite</tt> memory system, the module system, the regex engine and potentially more things. The prototype for	this function looks like this:</p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">int ferite_init( int argc, char **argv )</pre></td></tr></table><p class="para">	If you don't call this	it is likely that your program will crash and do various other undefined things. You may call this multiple times and it won't 	cause issues. It takes two arguments. The first is the number of elemetns contained in the argument array. 	The second is an array of strings. This is how options are passed into the engine. For a full list of the options that the	ferite engine accepts, please look at the command line program's help option. The next step is to setup the paths that ferite    looks for when seraching for a module.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br /></pre></td><td><pre class="code-linesright">ferite_add_library_search_path( XPLAT_LIBRARY_DIR );
ferite_set_library_native_path( NATIVE_LIBRARY_DIR );</pre></td></tr></table><p class="para">	Ferite does what it is told; One of the things that makes it very useful is the ability to control what modules are availible	to be loaded. You can obtain the system wide defaults using the <strong class="strong">ferite-config</strong> shell script. If you do not	call these then the <tt class="monospace">ferite</tt> engine will be unable to load any of the core modules and will only have the API that the application exports.	This is useful for both controlling what the scripters can do and preventing people from loading rogue modules into the system. With	the library paths setup, the next task is to ask ferite to compile a script for us. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">script = ferite_script_compile( scriptfile );</pre></td></tr></table><p class="para">	This line will compile the script that is in the file in the <tt class="monospace">scriptfile</tt> variable. It will always return	a script object. The return will either contain the error information or will be an executable script. It is also possible to	compile a string into script. For this you call <tt class="monospace">ferite_compile_string</tt>, it takes one argument which is the	script to compile. There are also two more functions, <tt class="monospace">ferite_script_compile_with_path</tt> and<tt class="monospace">ferite_compile_string_with_path</tt>, they both take the same arguments as their respective counterparts, with	the exception of an added argument. This is a null terminated array of search paths to add to the module system for the duration of	the compilation. For more in depth information about these two functions please refer to the C API. For reference here are their	prototypes:      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br /></pre></td><td><pre class="code-linesright">FeriteScript *ferite_compile_string( char *str );
FeriteScript *ferite_compile_string_with_path( char *str, char **paths );
FeriteScript *ferite_script_compile( char *filename );
FeriteScript *ferite_script_compile_with_path( char *filename, char **paths );</pre></td></tr></table><p class="para"> Having compiled the script, it is important to check to see if any errors have occured: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">if( ferite_has_compile_error( script ) )
{
    errmsg = ferite_get_error_log( script );
    fprintf( stderr, "[ferite: compile]\n%s", errmsg );
}</pre></td></tr></table><p class="para">	This is how we check that everything is working. Or not. <tt class="monospace">ferite_has_compile_error</tt> will return <tt class="monospace">FE_TRUE</tt> if there was a compile error and <tt class="monospace">FE_FALSE</tt> if not. If there is an error, the script will not be executable but you will be	able to get the error logs from the script as shown above. You will need to, when finished, delete the script, and still clean up the engine. 	You will also need to free the string returned using <tt class="monospace">ffree</tt>.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">ferite_script_execute( script );</pre></td></tr></table><p class="para">	If the program execution has got this far you will be wanting to run the script. You pass the script to	<tt class="monospace">ferite_script_execute</tt> which will execute the script. The return value is the return value 	from the script's main function. To find out whether a runtime error occured you will need to use the code 	below. <strong class="strong">NOTE:</strong> you can run scripts multiple times but it is not recommended, as the state of	the script can not be guaranteed. As with compilation, we need to check for errors after we have run the 	script: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br /></pre></td><td><pre class="code-linesright">if( ferite_has_runtime_error( script ) )
{
    errmsg = ferite_get_error_log( script );
    fprintf( stderr, "[ferite: execution]\n%s", errmsg );
}</pre></td></tr></table><p class="para"><tt class="monospace">ferite_has_runtime_error</tt> will return true if there has been a runtime error on the script. To	get the messages about the error you will need to use <tt class="monospace">ferite_get_error_log</tt>. This will return 	the error log as a C string. You will need to free the string returned with <tt class="monospace">ffree</tt>.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br /></pre></td><td><pre class="code-linesright">if( errmsg )
    ffree( errmsg );</pre></td></tr></table><p class="para">	Remember to free things!      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">ferite_script_delete( script );</pre></td></tr></table><p class="para">	Once you have finished with your script object you must delete it. This is a call to <tt class="monospace">ferite_script_delete</tt>.      </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">ferite_deinit( );</pre></td></tr></table><p class="para">	It's been a long day, you've been running scripts and it's now time to pack your bags and go home. There is one last	thing to be done - tell <tt class="monospace">ferite</tt> to deinitialise. This is done doing <tt class="monospace">ferite_deinit</tt>. This will cause	all allocated memory via <tt class="monospace">fmalloc/fcalloc/frealloc</tt> to be deallocated, shutdown the module system	and anything else that needs to be done. Once this has been called you can re-initialise the system with<tt class="monospace">ferite_init</tt> and start all over again. </p><p class="para">	So there you have it. That's how easy it is to get things up and running. It is suggest that you have a look at the 	command line program in the <tt class="monospace">ferite</tt> distribution for more options availible or a more concrete example. </p></blockquote><a name="ef-fake-native-modules"></a><a name="ef-fake-native-modules.title"></a><h2 class="sectionTitle">6.2. Fake Native Modules<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para">	Fake native modules provide a mechanism to export API from the current program to be included	when the script is compiled. This allows your scripts to talk to your program when they are being compiled. 	The example below assumes the methods <tt class="monospace">theapp_*</tt> compiled into the application. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br /></pre></td><td><pre class="code-linesright">ferite_module_register_fake_module( "theapp.lib", 
                    theapp_register, 
                    theapp_unregister, 
                    theapp_init, 
                    theapp_deinit );
ferite_module_add_preload( "theapp.lib" );</pre></td></tr></table><p class="para">	The <tt class="monospace">ferite_module_add_preload</tt> is important so that the module gets compiled	into the script at compile time and therefore allows for initialisation code that gets executed	to access the application. Please note that the <strong class="strong">.lib</strong> extension is very	important. This is so that <tt class="monospace">ferite</tt> knows that it is a native module and can handle it correctly	(and also find it). You should refer to the last section on writing native modules by hand for	the information on how to write the native module. For those of you feeling slightly more lazy,	read on, there is a cunning use of <tt class="monospace">builder</tt>.      </p><p class="para">	The above code should be placed before the calls to <tt class="monospace">ferite_script_compile</tt> or <tt class="monospace">ferite_compile_string</tt>.      </p></blockquote></blockquote> <hr class="sectionSplitter" /><a name="7-buildingmodules"></a><h1 class="sectionTitle">7. Building Modules<a href="#toc"><img border="0" src="http-int.png" /></a></h1><blockquote class="section"><p class="para"> The <tt class="monospace">ferite</tt> distribution currently ships with two mechanisms for building and deploying modules to            be run on a system with ferite installed. The first, <tt class="monospace">generate-module</tt> is a solution             based upon the GNU autotools chain,            this is considered to be the old and broken way of doing things due to the huge effort required to            make sure that it is compatible with the, on average, 5 different versions that ship with the different            operating systems. The second, <tt class="monospace">farm</tt>, is a build system written in <tt class="monospace">ferite</tt> to provide            a sane way of building libraries, modules and binaries. This method is the prefered method of deployment            but doesn't currently work on any platform other than Mac OS X and Linux. </p><p class="para"> At the moment, it is recommend that you ship modules using both methods such that the end user may choose            which path to take. </p><a name="71-mostcompatiblemethodgenerate-module"></a><h2 class="sectionTitle">7.1. Most Compatible Method: generate-module<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para"><tt class="monospace">ferite</tt> ships with the command line program called generate-module. This program takes the name of                a ferite module (ending in <tt class="monospace">.fec</tt>), and builds a autotools based distribution for you.                Lets assume we have a <tt class="monospace">f.fec</tt> module file, and a couple of utility c files that                provide helper functions for the code. To execute generate-module we do the following: </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br /></pre></td><td><pre class="code-linesright">generate-module f.fec utility.c utility.h</pre></td></tr></table><p class="para"> Assuming everything is ok, generate-module will create us a directory <tt class="monospace">f</tt>, and                build a autotools distribution. It will copy all the named files provided on the command line into                the distribution. To let you know this is happening, you will get an output like this:            </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br /></pre></td><td><pre class="code-linesright">Ferite Module Distributor (1.0)
Copyright (c) 2000-2002:
 
Chris Ross &lt;chris@ferite.org&gt;
Sveinung Haslestad &lt;sveinung@cention.se&gt;
Stephan Engstrom &lt;sem@cention.se&gt;

ferite-config: /opt/local/bin/ferite-config
builder: /opt/local/bin/builder
prefix: /opt/local
Using file 'f.fec'
Module name 'f'
Creating Directory 'f'
Reading directory: /opt/local/share/ferite/generate-module/skel
Reading file: .
Reading file: ..
Reading file: .cvsignore
Copying .cvsignore to f/
Reading file: AUTHORS
Copying AUTHORS to f/
Reading file: autogen.sh
Copying autogen.sh to f/
Reading file: ChangeLog
Copying ChangeLog to f/
Reading file: config.h.in
Copying config.h.in to f/
Reading file: configure.ac
Copying configure.ac to f/
Reading file: CVS
Reading file: Makefile.am
Copying Makefile.am to f/
Reading file: Makefile.in
Copying Makefile.in to f/
Reading file: README
Copying README to f/
Reading file: stamp-h.in
Copying stamp-h.in to f/
Reading file: udcl.sh
Copying udcl.sh to f/
Copying module source over...
Copying module source over...
Copying module source over...
Running builder...

Finished!, now to build a tarball run:

   cd f && ./autogen.sh && make dist

People will then be able to configure and install the tarball

If you wish to add any special checking to to the configure script
please edit f/config.m4</pre></td></tr></table><p class="para"> To use the module and generate a configure script, change into the directory and run <tt class="monospace">./autogen.sh</tt>.            </p></blockquote><a name="72-newmethodfarm"></a><h2 class="sectionTitle">7.2. New Method: farm<a href="#toc"><img border="0" src="http-int.png" /></a></h2><blockquote class="section"><p class="para"> At the moment, generating a module from a ferite module code is trivial with farm. To                tell farm what to do, it is necessary to generate a <tt class="monospace">farm.yard</tt> file                with the module descriptions. The following is a template detail how to build a module                and have it installed correctly. You may copy and paste the template into a file, replace                all occurances of <tt class="monospace">MODULENAME</tt> with the name of your module and                 you should be good to go. </p><table width="100%" cellspacing=0 cellpadding=0><tr><td align="right" width="50"><pre class="code-linesleft">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br /></pre></td><td><pre class="code-linesright">&lt;?xml version="1.0" ?&gt;
&lt;yard name="MODULENAME"&gt;

    &lt;module id="MODULENAME"&gt;
        &lt;list type="source"&gt;
            &lt;file name="source/MODULENAME.fec" /&gt;
            &lt;fileset dir="source" match="utility\.[ch]$" /&gt;
        &lt;/list&gt;
        &lt;property type="C"&gt;
            &lt;program-output program="ferite-config" arguments="--cflags" /&gt;
        &lt;/property&gt;
        &lt;property type="LD"&gt;\
            &lt;program-output program="ferite-config" arguments="--libs" /&gt;
        &lt;/property&gt;
        &lt;property type="prefix" value="$(FeriteModuleNativeDir)" /&gt;        
    &lt;/module&gt;
    
    &lt;phase id="install" depends="build"&gt;
        &lt;perform action="install" target="MODULENAME" /&gt;
        &lt;copy file="source/MODULENAME.fec" target="$(FeriteModuleSourceDir)" /&gt;
        &lt;copy file="$(ProductDir)/MODULENAME.xml" 
              target="$(FeriteModuleDescriptionDir)" /&gt;
        &lt;execute program="feritedoc" arguments="--regenerate" /&gt;
    &lt;/phase&gt;
    
&lt;/yard&gt;</pre></td></tr></table><p class="para"> The above farm.yard file describes the module, what files exist for the module and the                various properties that are required to build it. To use the farm file, you simply invoke <tt class="monospace">farm build</tt> to build the contents, and <tt class="monospace">farm install</tt> to install the built products. Everything generated by farm is always placed in the <tt class="monospace">FarmYard</tt> directory that can be found in the same location as the farm.yard file. </p></blockquote><p class="para"> This has been a very quick run through of the use of these tools. As farm mature much more             documentation will be released, however, it is still young (but very usable) and provides a great            mechanism for deploying code to a system that has a ferite runtime on it. </p></blockquote> <hr class="sectionSplitter" /><hr class="documentEnd" />
</body></html>
